use java.util.HashMap

use com.basiscomponents.db.ResultSet
use com.basiscomponents.db.ResultSetExporter

use ::RestBridge/OutputHandler.bbj::OutputHandler

use java.io.File
use java.io.FileInputStream
use java.io.FileOutputStream
use java.io.IOException
use java.util.zip.ZipEntry
use java.util.zip.ZipOutputStream

use java.nio.charset.Charset

class public RestBridge

    field public static BBjString LOGTPL$="ID:C(16*),METHOD:C(1*),START:N(1*),END:N(1*),DURATION:N(1*),ADDR:C(1*),URL:C(1*),URI:C(1*),QUERY:C(1*),HEADERS:C(1*),PARAMS:C(1*),STATUS:C(1*)"

    METHOD PUBLIC void service(BBxServletContext context!)
        declare BBxServletRequest request!
        declare BBxServletResponse response!
        
        request! = context!.getRequest()
        response! = context!.getResponse()

        debug = num(stbl("DEBUG",err=*next),err=*next)        
        if debug then
            System.out.println("REST request --------------------------")
            System.out.println("REST request METHOD "+request!.getMethod())
            System.out.println("REST request HEADER "+request!.getRequestURL())
            System.out.println("REST request end -----------------------")
        fi

        param! = context!.getInitParameter("REST_REQUESTLOG")
        if param! <> null() then
            void$ = stbl("REST_REQUESTLOG",param!)
        endif

        req_id$ = #logRequest(request!)

        if request!.getHeader("Origin") <> null() then
            response!.setHeader("Access-Control-Allow-Origin",request!.getHeader("Origin"))
        else
            response!.setHeader("Access-Control-Allow-Origin","*")
        endif
        
        response!.setHeader("Access-Control-Allow-Credentials","true")
        response!.setHeader("Access-Control-Allow-Methods","GET, POST, PUT, DELETE, OPTIONS")
        response!.setHeader("Access-Control-Allow-Headers",request!.getHeader("Access-Control-Request-Headers"))

        rem respond to ping
        tmp$=request!.getRequestURL()+$0000$
        if pos("/ping"+$0000$=tmp$)>0 OR pos("/Ping"+$0000$=tmp$)>0 then
            response!.getOutputStream().write("pong")
            response!.setStatus(200)        
            methodret
        fi
                
        files! = request!.getFileUploads()
        if (files! <> null()) then
            sz = files!.size()
            if sz then
              declare BBjFileUpload uploadFile!
              hm_resp! = new HashMap()
              for i=0 to sz-1
                      uploadFile! = cast(BBjFileUpload,files!.get(i))
                      if (debug) then
                          System.out.println(str("Field:" + uploadFile!.getFieldName()))
                          System.out.println(str("- Name:"+ uploadFile!.getOriginalName()))
                          System.out.println(str("- Temp Name:"+ uploadFile!.getTempName()))
                          System.out.println(str("- Type:"+ uploadFile!.getContentType()))
                          System.out.println(str("- Size:"))
                          System.out.println(str(uploadFile!.getContentLength()))
                          System.out.println(str("------------------------"))
                      fi

                      tmpname$= uploadFile!.getTempName()
                      newname!=tmpname$

                      oname$=str(uploadFile!.getOriginalName())
                      if oname$<>"" And oname$<>"null" then
                          newname$ = newname!.replace("\","/")
                          newname$=newname$(1,pos("/"=newname$,1,pos("/"=newname$,1,0)))
                          newname$=newname$+str(System.currentTimeMillis())+"/"
                          mkdir newname$
                          newname$=newname$+uploadFile!.getOriginalName()
                          rename tmpname$ TO newname$
                          hm_resp!.put(uploadFile!.getFieldName(),newname$)
                      fi
              next i

              resp$=""
              it! = hm_resp!.keySet().iterator()
              while it!.hasNext()
                    x$=it!.next()
                    x1$=hm_resp!.get(x$)
                    if resp$>"" then
                        resp$=resp$+","
                    fi
                    resp$=resp$+""""+x$+""":"""+x1$+""""
              wend

              response!.getOutputStream().write("{"+resp$+"}")
              response!.setStatus(200)
              #logResponse(req_id$,response!)
              methodret
           fi
        fi


        req! = new HashMap()

        switch request!.getMethod()
            case "GET"
                method$ = "GET"
            break
            case "OPTIONS"
                response!.setStatus(200)
                response!.setHeader("Access-Control-Max-Age","600")
                #logResponse(req_id$,response!)
                methodret
            break
            case "DELETE"
            case "PUT"
                method$ = request!.getMethod()
                rem Only JSON is supported for now
                
                if request!.getContentType() <> null() AND pos("application/json" = request!.getContentType()) = 0 then
                    s! = response!.getOutputStream()
                    response!.sendError(415,"Unsupported media type """+request!.getContentType()+"""")
                endif
            break
            case "POST"
                method$ = "POST"
                if request!.getHeader("ExecuteBCMethod") <> null() then
                    req!.put("invoke",request!.getHeader("ExecuteBCMethod"))
                    if request!.getHeader("BCReturnVarName") <> null() then
                        req!.put("retvarname",request!.getHeader("BCReturnVarName"))
                    endif
                endif
            break
            case default
                response!.setContentType("text/plain")
                s! = response!.getOutputStream()
                response!.sendError(501,"Unsupported HTTP method """+request!.getMethod()+"""")
                #logResponse(req_id$,response!)
                methodret
            break
        swend
        
        servletParams! = #getServletParameters(context!) 
        
        rem The authentication program might be relative to the WD but not to any directory in the prefix
        rem therefore switch to the WD for the authentication program call
        chdir servletParams!.get("REST_WD"), err=*next
    
        rem Retrieve the auth pgm to call 
        authpgm$="authenticate.bbj"     
        if servletParams!.get("REST_AUTHPGM") <> null() then
            authpgm$ = servletParams!.get("REST_AUTHPGM").toString()
        endif
    
        call authpgm$+"::PRE_AUTHENTICATION", err=*next
        
        if err = 21 AND auth$ = "" then
            System.out.println("***********************************")
            System.out.println("WARNING: Deprecated fallback code was used due to the missing label ""PRE_AUTHENTICATION"" in the authentication program")
            System.out.println("WARNING: Please consider to update the authentication program, as this fallback code will be removed in a later version")
            System.out.println("***********************************")
            
            auth$ = ""
            rem fallback to the old mechasnism
            token$=request!.getParameter("_TOKEN")
            if token$>"" then
                auth$="Basic "+token$
            fi
        
            token$=request!.getParameter("_JTOKEN")
            if token$>"" then
                auth$="Bearer "+token$
            fi
        
            if auth$="" then 
                auth$=str(request!.getHeader("authorization",err=*next))
            fi   
        
            if cvs(str(request!.getParameter("grant_type")),4) = "PASSWORD" then
                user$=request!.getParameter("username")
                password$=request!.getParameter("password")
                auth$="Basic "+java.util.Base64.getEncoder().encode(user$+":"+password$)
        
                rem we're using the Basic authentication way to pass username and password to the Adapter
                rem so that the "usual" login can be used to check the credentials
            fi
        endif
        
        if auth$="null" or len(auth$) < 8 then
            tmp$ = str(request!.getHeader("X-REQUESTED-WITH", err=*next))
            if tmp$ <> "XMLHttpRequest" then
                response!.setHeader("WWW-Authenticate", "Basic realm=""REST Web Service""")
            endif
            
            response!.sendError(401, "Authentication required")
            #logResponse(req_id$, response!)
            methodret
        endif
                
        rem create uid$ as a unique representant of the user
        rem this needs to contain the config file and the prefix!
        uid$ = hta(java.security.MessageDigest.getInstance("MD5").digest(auth$+BBjAPI().getConfig().getCurrentCommandLineObject().getConfigFile()+pfx))

        ses_list! = BBjAPI().getGlobalNamespace().getValue(uid$+"_list",err=*next)
        if ses_list! = null() then
            BBjAPI().getGlobalNamespace().setValue(uid$+"_list",new java.util.Stack())
            ses_list! = BBjAPI().getGlobalNamespace().getValue(uid$+"_list")
        endif

        while 1
            if (ses_list!.empty())
                servletParams! = #getServletParameters(context!)
                if !servletParams!.containsKey("REST_WD") then
                    goto setup_err
                endif
                
                if !servletParams!.containsKey("REST_ADAPTERPGM") then
                    goto setup_err
                endif

                ses$ = #newSession(auth$,servletParams!)
                break
            else
                ses$=ses_list!.pop()
                if (#checkSession(ses$)) then
                    break
                endif
            endif
        wend

        params! = new HashMap()
        it! = request!.getParameterNames().iterator()
        while it!.hasNext()
            p$=it!.next()
            params!.put(cvs(p$,4),request!.getParameter(p$))
        wend

        uri!=request!.getPathInfo()
        if uri! <> null() and uri!.lastIndexOf("/_output_") <> -1 then
            uri! = uri!.substring(0,uri!.lastIndexOf("/_output_"))
        fi

        req!.put("method",method$)
        req!.put("uri",uri!)
        req!.put("params",params!)
                
        contentType$ = ""
        type! = request!.getHeader("Content-Type", err=*next)
        if type! <> null() then
            contentType$ = str(type!)
        endif
        
        defaultCharset! = "UTF-8"
        servletParams! = #getServletParameters(context!)
        if servletParams!.containsKey("REST_DEFAULT_CHARSET") then
            defaultCharset! = str(servletParams!.get("REST_DEFAULT_CHARSET"))
            ok = 0; Charset.forName(defaultCharset!, err=*next); ok = 1
            if !ok then
                defaultCharset! = "UTF-8"
            endif
        endif
        
        requestCharSet$ = ""
        
        rem check if a charset has been specified in the Content-Type header 
        rem if the request is in a different charset, the Content-Type header should look like this:
        rem Content-Type: application/json ; charset=UTF-8
        if pos("charset=" = contentType$) then
            
            rem extracting the charset value
            requestCharSet$ = cvs(contentType$(pos("charset=" = contentType$) +8), 3)
            
            rem check if the charset was specified with quotes
            if pos("""" = requestCharSet$) then
                
                rem remove the quotes
                requestCharSet$ = requestCharSet$(2, len(requestCharSet$)-2)
            endif
            
            ok = 0; Charset.forName(requestCharSet$, err=*next); ok = 1
            
            if !ok then
                requestCharSet$ = ""
            endif
        endif
        
        headers! = new HashMap()
        headerNameList! = request!.getHeaderNames()
        it! = headerNameList!.iterator()
        while it!.hasNext()
            headerName! = it!.next()
            
            if !headerName!.equals("Authorization") then
                headers!.put(headerName!, request!.getHeader(headerName!))
            endif
        wend
        req!.put("headers", headers!)
        
        body! = request!.getBody(err=*next)
        if body! <> null() then     
            if requestCharSet$ = "" then
                body! = new String(body!, defaultCharset!).getBytes("ISO-8859-1")           
                body! = new String(body!, defaultCharset!).getBytes(info(1,2))
            else
                body! = new String(body!, requestCharSet$).getBytes(info(1,2))
            endif           
            
            req!.put("body", body!)
        endif
        
        req!.put("preferredlocales", request!.getLocales())

        if str(uri!)="/admin/requestlog" then
            answer! = #getRequestLog(request!)
        else
            answer! = #invoke(ses$,req!)
        fi
        ses_list!.push(ses$)

        accept$=str(params!.get("_ACCEPT"))
        if accept$="null" then
            accept$=str(request!.getHeader("Accept"))
        endif
        
        if accept$="null" then
            accept$=str(request!.getHeader("Content-Type"))
            if accept$="null" then
                accept$="text/html"
            fi
        fi
        
        rem check for multi-value accept headers
        atmp$=accept$
        alist!=new java.util.ArrayList()
        alist!.addAll(java.util.Arrays.asList(new String(accept$).split(",")))
        accept$ = ""
        it! = alist!.iterator()
        while it!.hasNext()
            accept$ = it!.next()
            if mask(accept$,"^debug|^text/html|^application/json|^text/csv|^text/plain|^application/xml|^*/*|^text/xml|^application/xls") then
                if pos(";"=accept$) then
                    accept$=cvs(accept$(1,pos(";"=accept$)-1),3)
                endif
                break
            endif
        wend

        if accept$ = "" then
            if debug then
                System.out.println("REST: error 406 Unsupported content type requested in Accept header: "+atmp$)
            fi
            response!.sendError(406, "Unsupported content type requested in Accept header: "+atmp$)
            #logResponse(req_id$,response!)
            methodret
        fi

        if debug then
            System.out.println("REST Accept: "+accept$)
        fi

        statuscode! = answer!.get("statuscode",err=*next)
        errormsg! = answer!.get("errormsg",err=*next)
        errorcode$ = str(answer!.get("errorcode"))

        blobdata$=str(params!.get("_BLOBDATA"))
       
        if debug then
            System.out.println(params!)
            System.out.println("BLOBDATA : "+blobdata$)
        fi
        
        if blobdata$<>"null" then
            rs! = answer!.get("resultset",err=*next)
            if rs! = null() or rs!.size() = 0 or !rs!.getItem(0).getFieldNames().contains(blobdata$) then
                goto blob_err
            fi

            blobname$=str(params!.get("_BLOBNAME"))
            if blobname$="null" then
                blobname$="attachment.dat"
            fi
            if pos("."=blobname$)>0 then
                ext$=blobname$(pos("."=blobname$,1,pos("."=blobname$,1,0))+1)
            fi
            d$=System.getProperty("basis.cacheDirectory")+"/_output_/"
            mkdir d$,err=*next            
            if rs!.size() = 1 and cvs(accept$,4)<>"APPLICATION/ZIP" then 
                wr! = new java.io.StringWriter()
                f! = java.io.File.createTempFile("output_", ext$, new java.io.File(d$))
                ch=unt
                open (ch)str(f!.toPath())
                write (ch)rs!.getItem(0).getFieldAsString(blobdata$,err=blob_err)
                close (ch)
    
                java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())
                f!.delete()
    
                response!.setContentType("application/"+ext$)
                response!.setHeader("Content-Disposition","inline; filename="""+blobname$+"""")
    
                #logResponse(req_id$,response!)
            else
              count=0
              tmpfiles! = new BBjVector()
              f! = java.io.File.createTempFile("output_", ".zip", new java.io.File(d$))
              fos! = new FileOutputStream(str(f!.toPath()))
              zos! = new ZipOutputStream(fos!)

              it! = rs!.iterator()
              while it!.hasNext()
                rec! = it!.next()
                blob$ = rec!.getFieldAsString(blobdata$,err=*continue)
                if blob$="" or (len(blob$)>4 and blob$(1,4)="!err") then continue
                count=count+1
                tmpname$=str(count:"00000000")+"_"+blobname$
                tmp$=tmp$+" "+tmpname$
                zos!.putNextEntry(new ZipEntry(tmpname$))
                zos!.write(blob$, 0, len(blob$))
                zos!.closeEntry()
              wend
              
              zos!.close()
                
                java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())
                f!.delete()
    
                response!.setContentType("application/zip")
                response!.setHeader("Content-Disposition","inline; filename=""files.zip""")
    
                #logResponse(req_id$,response!)

                
            fi
            methodret

            blob_err:
              response!.getOutputStream().write("BLOB not found")
              response!.setStatus(404)
              #logResponse(req_id$,response!)
              methodret
        endif


        if answer!.containsKey("file") then
            file$ = answer!.get("file")

            tryagain:

            ch=unt
            open (ch,err=filenotfund)file$
            close (ch)
                   
            if debug then
                System.out.println(file$)
            fi
            
            fullPath$ = BBjAPI().getFileSystem().resolvePath(file$)
            
            if debug then
                System.out.println(fullPath$)
            fi

            filename$=fullPath$
            if (pos("/"=filename$)>0) then
                filename$=filename$(pos("/"=filename$,1,pos("/"=filename$,1,0))+1)
            fi
            if (pos("\"=filename$)>0) then
                filename$=filename$(pos("\"=filename$,1,pos("\"=filename$,1,0))+1)
            fi

            ext$="dat"

            if pos("."=filename$)>0 then
                ext$=filename$(pos("."=filename$,1,pos("."=filename$,1,0))+1)
            fi

            f! = new java.io.File(fullPath$)
            java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())

            response!.setContentType("application/"+ext$)
            response!.setHeader("Content-Disposition","inline; filename="""+filename$+"""")

            goto done_file

            filenotfund:
            if debug then
                System.out.println("file not found")
            fi 
            response!.getOutputStream().write("file not found!")
            response!.setStatus(404)

            done_file:
            #logResponse(req_id$,response!)
            methodret
        endif

        if answer!.containsKey("stacktrace") then
            stacktrace$ = answer!.get("stacktrace")
        endif

        rem if the status code is not starting with 20, an error occurred
        if statuscode! <> null() and !mask(statuscode!,"20\d") then
            rem System.out.println("REST: error "+str(statuscode!)+" - "+str(errormsg!))
            if pos("application/json"=accept$) > 0 then
                response!.setStatus(num(statuscode!))
                response!.setContentType("application/json")
                rs! = answer!.get("resultset",err=*next)
                if method$ = "POST" and rs! <> null() and rs!.size() > 0 then
                    wr! = new java.io.StringWriter()
                    ResultSetExporter.writeJSON(rs!,wr!,restbridge_opt_jsonmeta)
                    wr!.flush()
                    wr!.close()
                    response!.getOutputStream().write(wr!.toString())
                    #logResponse(req_id$,response!)
                else
                    ok = 0; java.lang.Class.forName("org.apache.commons.lang.StringEscapeUtils", err=*next); ok = 1
                    if ok then
                        rem BBj 18.21 or older
                        escapedErrorMessage! = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(errormsg!)
                        escapedStacktrace! = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(stacktrace$)
                    else
                        rem BBj 19.00 or newer
                        escapedErrorMessage! = org.apache.commons.lang3.StringEscapeUtils.escapeEcmaScript(errormsg!)
                        escapedStacktrace! = org.apache.commons.lang3.StringEscapeUtils.escapeEcmaScript(stacktrace$)
                    endif 

                    e$ = "{""code"":"""+str(errorcode$)+""",""message"":"""+ escapedErrorMessage! +""","
                    if debug and statuscode! <> "401" then
                        e$ = e$ + """stacktrace"":"""+ escapedStacktrace! +""","
                    endif
                    e$ = e$ + """ses"":"""+ses$+"""}"
                    response!.getOutputStream().write(e$)
                endif
            else
                response!.setContentType("text/html")
                s! = response!.getOutputStream()
                s!.write("<html><head><meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""/><title>"+str(errormsg!)+"</title></head>")
                s!.write("<body><h2>HTTP ERROR "+str(statuscode!)+"</h2><p>Problem accessing "+request!.getRequestURI()+". Reason:<hr><blockquote><pre>!ERROR="+errorcode$+" "+str(errormsg!))
                if debug and statuscode! <> "401" then
                    s!.write($0a$+stacktrace$)
                endif
                s!.write("</pre></blockquote><hr></p></body></html>")
                response!.setStatus(num(statuscode!))
            endif
            rem ToDo: add error output for xml and csv
            #logResponse(req_id$,response!)
            methodret
        fi

        rs! = answer!.get("resultset",err=*next)
        pk! = answer!.get("primarykey",err=*next)
        if rs! = null()
            s! = response!.getOutputStream()
            s!.write(str(answer!))
            response!.setHeader("Reason-Phrase",str(errormsg!))
            if debug then
                System.out.println("REST: error 500 "+str(errormsg!))
            fi
            response!.sendError(500,str(errormsg!))
            #logResponse(req_id$,response!)
            methodret
        fi

        if method$ = "PUT" or method$ = "DELETE" then
            response!.setStatus(num(statuscode!))
            if method$ = "DELETE" then
                #logResponse(req_id$,response!)
                methodret
            endif
        endif

        if method$ = "POST" then
            if statuscode! <> null() then
                response!.setStatus(num(statuscode!))
            endif
            
            if str(rs!) = "" then
                #logResponse(req_id$,response!)
                methodret
            endif
        endif
        
        usedCharset! = ""
        
        rem check if a custom charset was provided in the Content-Type header
        if requestCharSet$ <> "" then
            rem Convert the ResultSet to the same charset as specified in the Content-Type header            
            usedCharset! = requestCharSet$    
        else
            if request!.getHeader("Accept-Charset") <> null() then
                charset! = request!.getHeader("Accept-Charset")
                
                if pos("," = charset!) then
                    rem split the charset and check if any of the accepted charset equals the default charset
                    splitCharset! = charset!.split(",")
                    for i=0 to splitCharset!.length -1
                        ok = 0; Charset.forName(cvs(splitCharset![i],3), err=*next); ok = 1
                        if ok then
                            usedCharset! = cvs(splitCharset![i],3)
                            converted = 1
                            break
                        endif
                        
                        if !converted then
                            rem fallback to default
                            usedCharset! = defaultCharset!
                        endif
                    next i
                else
                    if cvs(charset!, 3) = "*" then
                        rem all charsets are accepted, use the bridge's default
                        usedCharset! = defaultCharset!
                    else
                        rem check if the charset is valid
                        ok = 0; Charset.forName(charset!, err=*next); ok = 1                    
                        if ok then
                            usedCharset! = charset!
                        else
                            rem unknown charset, fall back to default
                            usedCharset! = defaultCharset!
                        endif
                    endif
                endif
            else
                rem no charset provided --> convert from the server encoding to the default bridge encoding
                usedCharset! = defaultCharset!
            endif
        endif
        
        #setCharacterSet(rs!, usedCharset!)
              
        rem Handling the output format
        seterr output_creation_error
            namespace! = BBjAPI().getGlobalNamespace()
            handler! = namespace!.getValue(ses$ + "_OUTPUT_HANDLER", err=*next)
            if handler! <> null() then
                outputHandler! = eval(handler!)
            else
                outputHandler! = new OutputHandler()
            endif
            
            outputHandler!.setResultSet(rs!)
            outputHandler!.setInvokeResult(answer!)
            
            rem set the charset 
            outputHandler!.setCharset(usedCharset!)
            
            outputHandler!.setResponse(response!)
            outputHandler!.setRequest(request!)
            
            rem final call
            outputHandler!.createOutput(accept$)
                        
            response!.setStatus(200)
            #logResponse(req_id$,response!)
            methodret
        
        output_creation_error:
            rem Set the output type to plain to display the error message properly
            response!.setContentType("text/plain")
            response!.sendError(500, "Failed to create the request output type: " + errmes(-1))
            #logResponse(req_id$,response!)
            methodret

        setup_err:
            response!.setContentType("text/plain")
            s! = response!.getOutputStream()
            s!.write("stbl not set up correctly!")
            if debug then
                System.out.println("REST: error 500 STBLs not set up correctly! Need REST_WD and REST_ADAPTERPGM in config.bbx" )
            fi
            response!.sendError(500,"STBLs not set up correctly! Need REST_WD and REST_ADAPTERPGM in config.bbx" )
            #logResponse(req_id$,response!)
    methodend


    method private Boolean checkSession(BBjString ses$)

        requestSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_REQUEST_SEM",err=noSes)
        responseSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_RESPONSE_SEM")

        namespace! = BBjAPI().getGlobalNamespace() 
        namespace!.setValue(ses$+"_REQUEST","PING")

        requestSemaphore!.release()
        if !responseSemaphore!.tryAcquire(1,1,java.util.concurrent.TimeUnit.SECONDS) then
            namespace!.removeValue(ses$+"_REQUEST")
            namespace!.removeValue(ses$+"_RESPONSE")
            namespace!.removeValue(ses$+"_REQUEST_SEM")
            namespace!.removeValue(ses$+"_RESPONSE_SEM")
            namespace!.removeValue(ses$+"_SERVLET_PARAMETERS")
            namespace!.removeValue(ses$+"_OUTPUT_HANDLER", err=*next)
            namespace!.removeValue(ses$+"_INPUT_HANDLER", err=*next)
            
            methodret Boolean.FALSE
        fi

        methodret Boolean.TRUE

        noSes:
            methodret Boolean.FALSE

    methodend

    rem /**
    rem  * This method converts the VARCHAR and LONGVARCHAR field values 
    rem  * of the given ResultSet to the given charset. 
    rem  * 
    rem  * This method is used when the Accept-Charset header was specified 
    rem  * so that the RestBridge returns the Data in the requested charset.
    rem  * 
    rem  * @param resultSet! The ResultSet whose VARCHAR and LONGVARCHAR fields will be converted
    rem  * @param charset! The character Set to use for the VARCHAR fields
    rem  *
    rem  */
    method private static void setCharacterSet(ResultSet resultSet!, String charset!)
        charsetIsSupported! = Boolean.FALSE
        charsetIsSupported! = Charset.isSupported(charset!, err=*next)
        if !charsetIsSupported! then
            methodret
        endif

        if resultSet! = null() or resultSet!.isEmpty() then
            methodret 
        endif

        rsIterator! = resultSet!.iterator()
        while rsIterator!.hasNext()
            dataRow! = rsIterator!.next()
            
            fieldNames! = dataRow!.getFieldNames()
            if fieldNames!.isEmpty() then
                continue
            endif
            
            fieldNameIterator! = fieldNames!.iterator()
            while fieldNameIterator!.hasNext()
                fieldName! = fieldNameIterator!.next()

                fieldType! = dataRow!.getFieldType(fieldName!)
                if fieldType! = java.sql.Types.VARCHAR OR fieldType! = java.sql.Types.LONGVARCHAR then
                    body! = dataRow!.getFieldAsString(fieldName!)                   
                    body! = new String(new String(body!, info(1,2)).getBytes(charset!), charset!)                    
                    dataRow!.setFieldValue(fieldName!, body!)
                endif
            wend
        wend
    methodend

    method public static BBjString newSession(BBjString auth$, HashMap servletParams!)
        namespace! = BBjAPI().getGlobalNamespace()
        debug = num(stbl("DEBUG",err=*next),err=*next)

        rem create a new session
        while 1
            ses$=str(java.util.UUID.randomUUID())
            print "trying to create session "+ses$
            namespace!.getValue(ses$+"_REQUEST",err=*next); continue
            break
        wend
        
        if debug then
            System.out.println("REST: create "+ses$)
        fi
        namespace!.setValue(ses$+"_REQUEST","")
        namespace!.setValue(ses$+"_RESPONSE","")
        namespace!.setValue(ses$+"_SERVLET_PARAMETERS",servletParams!)
        
        seterr custom_input_handler_error
            if servletParams!.containsKey("REST_INPUT_HANDLER") then    
                path$ = BBjAPI().getFileSystem().resolvePath(str(servletParams!.get("REST_INPUT_HANDLER")), err=*next)
                
                customOutputHandler! = new File(path$)
                if customOutputHandler!.exists() AND customOutputHandler!.isFile() then
                    className! = org.apache.commons.io.FilenameUtils.removeExtension(customOutputHandler!.getName())
                    outputHandler! = "new ::" + customOutputHandler!.getPath() + "::" + className! + "()"
                    namespace!.setValue(ses$ + "_INPUT_HANDLER", outputHandler!)
                endif
            endif 
          
        custom_input_handler_error:
        seterr 0
        
        seterr custom_output_handler_error
            if servletParams!.containsKey("REST_OUTPUT_HANDLER") then    
                path$ = BBjAPI().getFileSystem().resolvePath(str(servletParams!.get("REST_OUTPUT_HANDLER")), err=*next)
                
                customOutputHandler! = new File(path$)
                if customOutputHandler!.exists() AND customOutputHandler!.isFile() then
                    className! = org.apache.commons.io.FilenameUtils.removeExtension(customOutputHandler!.getName())
                    outputHandler! = "new ::" + customOutputHandler!.getPath() + "::" + className! + "()"
                    namespace!.setValue(ses$ + "_OUTPUT_HANDLER", outputHandler!)
                endif
            endif 
          
        custom_output_handler_error:
        seterr 0

        requestSemaphore! = new java.util.concurrent.Semaphore(0)
        responseSemaphore! = new java.util.concurrent.Semaphore(0)
        namespace!.setValue(ses$+"_REQUEST_SEM",requestSemaphore!)
        namespace!.setValue(ses$+"_RESPONSE_SEM",responseSemaphore!)

        cp$=BBjAPI().getConfig().getCurrentCommandLineObject().getOriginalClasspathName()
        if cp$>"" cp$=" -CP"+cp$
        wd$= " -WD"+ servletParams!.get("REST_WD").toString()
        pgm$ = " """ + servletParams!.get("REST_ADAPTERPGM").toString() + """"


        cfg$=" -c"+BBjAPI().getConfig().getCurrentCommandLineObject().getConfigFile()
        t$=" -t"+BBjAPI().getConfig().getCurrentCommandLineObject().getTerminal()
        if servletParams!.containsKey("REST_ADAPTERTERM") then
            t$=" -t"+servletParams!.get("REST_ADAPTERTERM").toString()
        endif

        scmd$="bbj -q "+ t$ + cfg$ + cp$ + wd$ + pgm$ + " - " + ses$ + " " + auth$ + " &"
        if debug then
            System.out.println("REST: create "+scmd$)
        fi
        a=scall(scmd$)

        methodret ses$
    methodend

    method public static HashMap invoke(BBjString ses$, HashMap instructions!)

        debug = num(stbl("DEBUG",err=*next),err=*next)
        
        if debug then
            System.out.println("REST: invoke "+ses$)
        fi
        
        requestSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_REQUEST_SEM",err=noSes)
        responseSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_RESPONSE_SEM")

        namespace! = BBjAPI().getGlobalNamespace()
        namespace!.setValue(ses$+"_REQUEST",instructions!)
        requestSemaphore!.release()
        rem here's the remote session active

        if !responseSemaphore!.tryAcquire(1,60,java.util.concurrent.TimeUnit.SECONDS) then
        
            if debug then
                System.out.println("Bridge: Timeout waiting on "+ses$)
            fi
            
            namespace!.removeValue(ses$+"_REQUEST")
            namespace!.removeValue(ses$+"_RESPONSE")
            namespace!.removeValue(ses$+"_REQUEST_SEM")
            namespace!.removeValue(ses$+"_RESPONSE_SEM")
            namespace!.removeValue(ses$+"_SERVLET_PARAMETERS")
            namespace!.removeValue(ses$+"_OUTPUT_HANDLER", err=*next)
            namespace!.removeValue(ses$+"_INPUT_HANDLER", err=*next)
            throw "Timeout occurred",0
        fi

        response! = namespace!.getValue(ses$+"_RESPONSE",err=*next)
        if debug then
            System.out.println("REST: invoke done "+ses$)
        fi
        
        methodret response!


        noSes:
            throw  "Session invalid",11

    methodend

    method private BBjString logRequest(BBxServletRequest request!)

        rlog$=stbl("REST_REQUESTLOG",err=skip)
        
        id$=""

        ch=unt
        open (ch)rlog$

        dim log$:#LOGTPL$

        id$=str(System.currentTimeMillis())+"_"+str(dec(INFO(3,0)):"000000")

        log.id$=id$
        log.METHOD$=str(request!.getMethod())
        log.START=System.currentTimeMillis()
        log.ADDR$=str(request!.getRemoteAddr())
        log.URI$=str(request!.getRequestURI())
        log.URL$=str(request!.getRequestURL())
        log.QUERY$=str(request!.getQueryString())

        h! = request!.getHeaderNames()
        it! = h!.iterator()
        while it!.hasNext()
            headerName$ = it!.next()
            headerValue$ = str(request!.getHeader(headerName$))
            
            rem Obfuscating the Authorization headers
            if headerName$ = "Authorization" then
                headerValue$ = new String(headerValue$).replaceAll("\s.*", " ************")
            endif
            
            headers$ = headers$ + headerName$ + "=" + headerValue$ + ","
        wend
        log.HEADERS$ = headers$

        p! = request!.getParameterNames()
        it! =p!.iterator()
        while it!.hasNext()
            pn$=it!.next()
            p$=p$+pn$+"="+str(request!.getParameter(pn$))+","
        wend
        log.PARAMS$=p$

        write record (ch)log$

        close (ch)

        skip:

        methodret id$

    methodend

    method private void logResponse(BBjString id$, BBxServletResponse response!)

        if id$="" then
            methodret
        fi

        rlog$=stbl("REST_REQUESTLOG",err=skip)

        ch=unt
        open (ch,err=skip)rlog$

        dim log$:#LOGTPL$
        log.id$=id$

        read record (ch,dom=skip,key=log.id$)log$
        log.END=System.currentTimeMillis()
        log.DURATION = log.END-log.START

        log.STATUS$=STR(response!.getStatus())

        write record (ch)log$

        close (ch)

        skip:

    methodend

    method private HashMap getRequestLog(BBxServletRequest request!)

        answer! = new HashMap()
        rs! = new ResultSet()

        rlog$=stbl("REST_REQUESTLOG",err=skip)


        ch=unt
        open (ch,err=skip)rlog$

        tpl$=#LOGTPL$
        dim log$:tpl$

        while 1
            read record (ch,end=*break)log$
            dr! = com.basiscomponents.db.DataRow.fromTemplate(tpl$,log$)
            rs!.addItem(dr!)
        wend

        close (ch)

        answer!.put("statuscode","200")
        answer!.put("resultset",rs!)
        answer!.put("single",0)
        methodret answer!

        skip:
            answer!.put("statuscode","404")
            answer!.put("errormsg","request logging not enabled")
            answer!.put("single",0)
            methodret answer!

    methodend

    rem /**
    rem  * Returns a HashMap containing the parameter names and values defined for the RestBridge.
    rem  * <br>
    rem  * It is currently possible to define the RestBridge parameters in the servlet configuration 
    rem  * and in the servlet's config.bbx file. This method prioritizes the servlet parameters, meaning 
    rem  * if a RestBridge parameter is defined as servlet parameter and in the config.bbx, the parameter 
    rem  * from the servlet configuration will be added to the HashMap.
    rem  * <br>
    rem  * The current RestBridge parameters are: <br>
    rem  * <ul>
    rem  *     <li>REST_PGM_PREFIX</li>
    rem  *     <li>REST_PGM_SUFFIX</li>
    rem  *     <li>REST_WD</li>
    rem  *     <li>REST_ADAPTERPGM</li>
    rem  *     <li>REST_ADAPTERTERM</li>
    rem  *     <li>REST_TIMEOUT</li>
    rem  *     <li>REST_AUTHPGM</li>
    rem  *     <li>REST_REQUESTLOG</li>
    rem  *     <li>USE_GET_ALLOWED_FILTER</li>
    rem  *     <li>REST_INPUT_HANDLER</li>
    rem  *     <li>REST_OUTPUT_HANDLER</li>
    rem  *     <li>REST_DEFAULT_CHARSET</li>
    rem  * </ul>
    rem  * <br>
    rem  * Some of these parameters are explicitly required to be set as STBLs. This method will set them 
    rem  * as STBL if required, so that the user can define all parameters in one place.
    rem  * 
    rem  * @param context! The servlet context used to read the parameters defined for the RestBridge servlet
    rem  * @return a HashMap with the RestBridge parameters(=options) currenlty set.
    rem  */
    method private static HashMap getServletParameters(BBxServletContext context!)

        rem the list of available parameter names
        declare BBjVector parameterNames!
        parameterNames! = new BBjVector()
        parameterNames!.add("REST_PGM_PREFIX")
        parameterNames!.add("REST_PGM_SUFFIX")
        parameterNames!.add("REST_WD")
        parameterNames!.add("REST_ADAPTERPGM")
        parameterNames!.add("REST_ADAPTERTERM")
        parameterNames!.add("REST_TIMEOUT")
        parameterNames!.add("REST_SERVLET_TIMEOUT")
        parameterNames!.add("REST_MAX_WORKER_RECYCLECOUNT")
        parameterNames!.add("REST_AUTHPGM")
        parameterNames!.add("REST_REQUESTLOG")
        parameterNames!.add("USE_GET_ALLOWED_FILTER")
        parameterNames!.add("REST_OUTPUT_HANDLER")
        parameterNames!.add("REST_INPUT_HANDLER")
        parameterNames!.add("REST_DEFAULT_CHARSET")
        
        parameterNames!.add("GRANT_TYPE")
        parameterNames!.add("USERNAME")
        parameterNames!.add("PASSWORD")

        rem the list of parameter names that must be set as STBL 
        declare BBjVector parameterNamesToSetAsSTBL!
        parameterNamesToSetAsSTBL! = new BBjVector()
        parameterNamesToSetAsSTBL!.add("REST_WD")
        parameterNamesToSetAsSTBL!.add("REST_ADAPTERPGM")
        parameterNamesToSetAsSTBL!.add("REST_REQUESTLOG")

        declare HashMap parameterMap!
        declare BBjString parameterValue!

        rem the map to fill with the parameter names and values
        parameterMap! = new HashMap()
        for i=0 to parameterNames!.size() -1
            parameterName! = parameterNames!.get(i)
            parameterValue! = context!.getInitParameter(parameterName!)

            if parameterValue! <> null() then
                parameterMap!.put(parameterName!,parameterValue!)

                rem Setting the parameter as STBL
                if parameterNamesToSetAsSTBL!.contains(parameterName!) then
                    void$ = stbl(parameterName!,parameterValue!)
                endif
            else
                parameterMap!.put(parameterName!,stbl(parameterName!,err=*next))
            endif
        next i

        methodret parameterMap!
    methodend

classend
