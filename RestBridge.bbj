use java.util.HashMap

use java.io.ByteArrayOutputStream
use java.util.zip.GZIPOutputStream
use javax.servlet.ServletOutputStream

use com.basiscomponents.db.ResultSet
use com.basiscomponents.db.ResultSetExporter

use java.io.File
use java.io.FileInputStream
use java.io.FileOutputStream
use java.io.IOException
use java.util.zip.ZipEntry
use java.util.zip.ZipOutputStream

class public RestBridge

    field public static BBjString LOGTPL$="ID:C(16*),METHOD:C(1*),START:N(1*),END:N(1*),DURATION:N(1*),ADDR:C(1*),URL:C(1*),URI:C(1*),QUERY:C(1*),HEADERS:C(1*),PARAMS:C(1*),STATUS:C(1*)"

    METHOD PUBLIC void service(BBjspServletContext context!)

        declare BBjspWebRequest request!
        declare BBjspWebResponse response!

        request! = context!.getRequest()
        response! = context!.getResponse()

        debug = num(stbl("DEBUG",err=*next),err=*next)
        restbridge_opt_jsonmeta=1
        restbridge_opt_jsonmeta=int(num(stbl("RESTBRIDGE_OPT_JSONMETA",err=*next),err=*next))
        
        restbridge_opt_enablegzip=1
        restbridge_opt_enablegzip=int(num(stbl("RESTBRIDGE_OPT_ENABLEGZIP",err=*next),err=*next))
        
        if debug then
            System.out.println("REST request --------------------------")
            System.out.println("REST request METHOD "+request!.getMethod())
            System.out.println("REST request HEADER "+request!.getRequestURL())
            System.out.println("REST request end -----------------------")
        fi

        param! = context!.getInitParameter("REST_REQUESTLOG")
        if param! <> null() then
            void$ = stbl("REST_REQUESTLOG",param!)
        endif

        req_id$ = #logRequest(request!)

        if request!.getHeader("Origin") <> null() then
            response!.setHeader("Access-Control-Allow-Origin",request!.getHeader("Origin"))
    	else
	        response!.setHeader("Access-Control-Allow-Origin","*")
        endif
        response!.setHeader("Access-Control-Allow-Credentials","true")
        response!.setHeader("Access-Control-Allow-Methods","GET, POST, PUT, DELETE, OPTIONS")
        response!.setHeader("Access-Control-Allow-Headers",request!.getHeader("Access-Control-Request-Headers"))


        files! = request!.getFileUploads()
        if (files! <> null()) then
            sz = files!.size()
            if sz then
              declare BBjFileUpload uploadFile!
              hm_resp! = new HashMap()
              for i=0 to sz-1
                      uploadFile! = cast(BBjFileUpload,files!.get(i))
                      if (debug) then
                          System.out.println(str("Field:" + uploadFile!.getFieldName()))
                          System.out.println(str("- Name:"+ uploadFile!.getOriginalName()))
                          System.out.println(str("- Temp Name:"+ uploadFile!.getTempName()))
                          System.out.println(str("- Type:"+ uploadFile!.getContentType()))
                          System.out.println(str("- Size:"))
                          System.out.println(str(uploadFile!.getContentLength()))
                          System.out.println(str("------------------------"))
                      fi

                      tmpname$= uploadFile!.getTempName()
                      newname!=tmpname$

                      oname$=str(uploadFile!.getOriginalName())
                      if oname$<>"" And oname$<>"null" then
                          newname$ = newname!.replace("\","/")
                          newname$=newname$(1,pos("/"=newname$,1,pos("/"=newname$,1,0)))
                          newname$=newname$+str(System.currentTimeMillis())+"/"
                          mkdir newname$
                          newname$=newname$+uploadFile!.getOriginalName()
                          rename tmpname$ TO newname$
                          hm_resp!.put(uploadFile!.getFieldName(),newname$)
                      fi
              next i

              resp$=""
              it! = hm_resp!.keySet().iterator()
              while it!.hasNext()
                    x$=it!.next()
                    x1$=hm_resp!.get(x$)
                    if resp$>"" then
                        resp$=resp$+","
                    fi
                    resp$=resp$+""""+x$+""":"""+x1$+""""
              wend

              response!.getOutputStream().write("{"+resp$+"}")
              response!.setStatus(200)
              #logResponse(req_id$,response!)
              methodret
           fi
        fi


        req! = new HashMap()

        switch request!.getMethod()
            case "GET"
                method$ = "GET"
            break
            case "OPTIONS"
                response!.setStatus(200)
                response!.setHeader("Access-Control-Max-Age","600")
                #logResponse(req_id$,response!)
                methodret
            break
            case "DELETE"
            case "PUT"
                method$ = request!.getMethod()
                rem Only JSON is supported for now
                if request!.getContentType() <> null() AND cvs(request!.getContentType(),8) <> "application/json" then
                    s! = response!.getOutputStream()
                    response!.sendError(415,"Unsupported media type """+request!.getContentType()+"""")
                endif
            break
            case "POST"
                method$ = "POST"
                if request!.getHeader("ExecuteBCMethod") <> null() then
                    req!.put("invoke",request!.getHeader("ExecuteBCMethod"))
                    if request!.getHeader("BCReturnVarName") <> null() then
                        req!.put("retvarname",request!.getHeader("BCReturnVarName"))
                    endif
                endif
            break
            case default
                response!.setContentType("text/plain")
                s! = response!.getOutputStream()
                response!.sendError(501,"Unsupported HTTP method """+request!.getMethod()+"""")
                #logResponse(req_id$,response!)
                methodret
            break
        swend

        token$=request!.getParameter("_TOKEN")
        if token$>"" then
            auth$="Basic "+token$
        else
            auth$=str(request!.getHeader("authorization",err=*next))
        fi

        if cvs(request!.getParameter("grant_type"),4) = "PASSWORD" then
            user$=request!.getParameter("username")
            password$=request!.getParameter("password")
            auth$="Basic "+java.util.Base64.getEncoder().encode(user$+":"+password$)
            rem we're using the Basic authentication way to pass username and password to the Adapter
            rem so that the "usual" login can be used to check the credentials
        fi
        
        if auth$="null" or len(auth$)<8 OR (cvs(auth$(1,5),4)<>"BASIC" AND cvs(auth$(1,6),4)<>"BEARER")then
            tmp$=str(request!.getHeader("X-REQUESTED-WITH",err=*next))
            if tmp$<> "XMLHttpRequest" then
                response!.setHeader("WWW-Authenticate","Basic realm=""REST Web Service""")
            fi
            response!.sendError(401,"Authentication required")
            #logResponse(req_id$,response!)
            methodret
        else
			rem create uid$ as a unique representant of the user
			rem this needs to contain the config file and the prefix!
            uid$ = hta(java.security.MessageDigest.getInstance("MD5").digest(auth$+BBjAPI().getConfig().getCurrentCommandLineObject().getConfigFile()+pfx))
        fi

        ses_list! = BBjAPI().getGlobalNamespace().getValue(uid$+"_list",err=*next)
        if ses_list! = null() then
            BBjAPI().getGlobalNamespace().setValue(uid$+"_list",new java.util.Stack())
            ses_list! = BBjAPI().getGlobalNamespace().getValue(uid$+"_list")
        endif

        servletParams! = #getServletParameters(context!)
        while 1
            if (ses_list!.empty())
                if !servletParams!.containsKey("REST_WD") then
                    goto setup_err
                endif
                if !servletParams!.containsKey("REST_ADAPTERPGM") then
                    goto setup_err
                endif

                ses$=#newSession(auth$,servletParams!)
                break
            else
                ses$=ses_list!.pop()
                if (#checkSession(ses$)) then
                    break
                endif
            endif
        wend

        params! = new HashMap()
        it! = request!.getParameterNames().iterator()
        while it!.hasNext()
            p$=it!.next()
            params!.put(cvs(p$,4),request!.getParameter(p$))
        wend

        uri!=request!.getPathInfo()
        if uri! <> null() and uri!.lastIndexOf("/_output_") <> -1 then
            uri! = uri!.substring(0,uri!.lastIndexOf("/_output_"))
        fi

        req!.put("method",method$)
        req!.put("uri",uri!)
        req!.put("params",params!)
        req!.put("body",request!.getBody(err=*next))
        req!.put("preferredlocales",request!.getLocales())

        if str(uri!)="/admin/requestlog" then
            answer! = #getRequestLog(request!)
        else
            answer!=#invoke(ses$,req!)
        fi
        ses_list!.push(ses$)

        accept$=str(params!.get("_ACCEPT"))
        if accept$="null" then
            accept$=str(request!.getHeader("Accept"))
        endif
        if accept$="null" then
            accept$=str(request!.getHeader("Content-Type"))
            if accept$="null" then
                accept$="text/html"
            fi
        fi
        
        accept_enc$=str(request!.getHeader("Accept-Encoding"))
        if pos("gzip"=accept_enc$) > 0 then
            do_gzip=1
        fi

        rem check for multi-value accept headers
        atmp$=accept$
        alist!=new java.util.ArrayList()
        alist!.addAll(java.util.Arrays.asList(new String(accept$).split(",")))
        accept$ = ""
        it! = alist!.iterator()
        while it!.hasNext()
            accept$ = it!.next()
            if mask(accept$,"^debug|^text/html|^application/json|^text/csv|^text/plain|^application/xml|^*/*|^text/xml|^application/xls") then
                if pos(";"=accept$) then
                    accept$=cvs(accept$(1,pos(";"=accept$)-1),3)
                endif
                break
            endif
        wend

        if accept$ = "" then
            if debug then
                System.out.println("REST: error 406 Unsupported content type requested in Accept header: "+atmp$)
            fi
            response!.sendError(406, "Unsupported content type requested in Accept header: "+atmp$)
            #logResponse(req_id$,response!)
            methodret
        fi

        if debug then
            System.out.println("REST Accept: "+accept$)
        fi

        statuscode! = answer!.get("statuscode",err=*next)
        errormsg! = answer!.get("errormsg",err=*next)
        errorcode$ = str(answer!.get("errorcode"))

        blobdata$=str(params!.get("_BLOBDATA"))
        System.out.println(params!)
        System.out.println("BLOBDATA : "+blobdata$)
        if blobdata$<>"null" then
            rs! = answer!.get("resultset",err=*next)
            if rs! = null() or rs!.size() = 0 or !rs!.getItem(0).getFieldNames().contains(blobdata$) then
                goto blob_err
            fi

            blobname$=str(params!.get("_BLOBNAME"))
            if blobname$="null" then
                blobname$="attachment.dat"
            fi
            if pos("."=blobname$)>0 then
                ext$=blobname$(pos("."=blobname$,1,pos("."=blobname$,1,0))+1)
            fi
            d$=System.getProperty("basis.cacheDirectory")+"/_output_/"
            mkdir d$,err=*next            
            if rs!.size() = 1 and cvs(accept$,4)<>"APPLICATION/ZIP" then 
                wr! = new java.io.StringWriter()
                f! = java.io.File.createTempFile("output_", ext$, new java.io.File(d$))
                ch=unt
                open (ch)str(f!.toPath())
                write (ch)rs!.getItem(0).getFieldAsString(blobdata$,err=blob_err)
                close (ch)
    
                java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())
                f!.delete()
    
                response!.setContentType("application/"+ext$)
                response!.setHeader("Content-Disposition","inline; filename="""+blobname$+"""")
    
                #logResponse(req_id$,response!)
            else
              count=0
              tmpfiles! = new BBjVector()
              f! = java.io.File.createTempFile("output_", ".zip", new java.io.File(d$))
              fos! = new FileOutputStream(str(f!.toPath()))
              zos! = new ZipOutputStream(fos!)

              it! = rs!.iterator()
              while it!.hasNext()
                rec! = it!.next()
                blob$ = rec!.getFieldAsString(blobdata$,err=*continue)
                if blob$="" or (len(blob$)>4 and blob$(1,4)="!err") then continue
                count=count+1
                tmpname$=str(count:"00000000")+"_"+blobname$
                tmp$=tmp$+" "+tmpname$
                zos!.putNextEntry(new ZipEntry(tmpname$))
                zos!.write(blob$, 0, len(blob$))
                zos!.closeEntry()
              wend
              
              zos!.close()
                
                java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())
                f!.delete()
    
                response!.setContentType("application/zip")
                response!.setHeader("Content-Disposition","inline; filename=""files.zip""")
    
                #logResponse(req_id$,response!)

                
            fi
            methodret

            blob_err:
              response!.getOutputStream().write("BLOB not found")
              response!.setStatus(404)
              #logResponse(req_id$,response!)
              methodret
        endif


        if answer!.containsKey("file") then
            file$ = answer!.get("file")

            tryagain:

            ch=unt
            open (ch,err=filenotfund)file$
            close (ch)
            System.out.println(file$)
            fullPath$ = BBjAPI().getFileSystem().resolvePath(file$)
            System.out.println(fullPath$)

            filename$=fullPath$
            if (pos("/"=filename$)>0) then
                filename$=filename$(pos("/"=filename$,1,pos("/"=filename$,1,0))+1)
            fi
            if (pos("\"=filename$)>0) then
                filename$=filename$(pos("\"=filename$,1,pos("\"=filename$,1,0))+1)
            fi

            ext$="dat"

            if pos("."=filename$)>0 then
                ext$=filename$(pos("."=filename$,1,pos("."=filename$,1,0))+1)
            fi

            f! = new java.io.File(fullPath$)
            java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())

            response!.setContentType("application/"+ext$)
            response!.setHeader("Content-Disposition","inline; filename="""+filename$+"""")

            goto done_file

            filenotfund:
            System.out.println("not found")

            response!.getOutputStream().write("file not found!")
            response!.setStatus(404)

            done_file:
            #logResponse(req_id$,response!)
            methodret
        endif

        if answer!.containsKey("stacktrace") then
            stacktrace$ = answer!.get("stacktrace")
        endif

        rem if the status code is not starting with 20, an error occurred
        if statuscode! <> null() and !mask(statuscode!,"20\d") then
            rem System.out.println("REST: error "+str(statuscode!)+" - "+str(errormsg!))
            if pos("application/json"=accept$) > 0 then
                response!.setStatus(num(statuscode!))
                response!.setContentType("application/json")
                rs! = answer!.get("resultset",err=*next)
                if method$ = "POST" and rs! <> null() and rs!.size() > 0 then
                    wr! = new java.io.StringWriter()
                    ResultSetExporter.writeJSON(rs!,wr!,restbridge_opt_jsonmeta)
                    wr!.flush()
                    wr!.close()
                    response!.getOutputStream().write(wr!.toString())
                    #logResponse(req_id$,response!)
                else
                    ok = 0; java.lang.Class.forName("org.apache.commons.lang.StringEscapeUtils", err=*next); ok = 1
                    if ok then
                        rem BBj 18.21 or older
                        escapedErrorMessage! = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(errormsg!)
                        escapedStacktrace! = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(stacktrace$)
                    else
                        rem BBj 19.00 or newer
                        escapedErrorMessage! = org.apache.commons.lang3.StringEscapeUtils.escapeEcmaScript(errormsg!)
                        escapedStacktrace! = org.apache.commons.lang3.StringEscapeUtils.escapeEcmaScript(stacktrace$)
                    endif 

                    e$ = "{""code"":"""+str(errorcode$)+""",""message"":"""+ escapedErrorMessage! +""","
                    if debug and statuscode! <> "401" then
                        e$ = e$ + """stacktrace"":"""+ escapedStacktrace! +""","
                    endif
                    e$ = e$ + """ses"":"""+ses$+"""}"
                    response!.getOutputStream().write(e$)
                endif
            else
                response!.setContentType("text/html")
                s! = response!.getOutputStream()
                s!.write("<html><head><meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8""/><title>"+str(errormsg!)+"</title></head>")
                s!.write("<body><h2>HTTP ERROR "+str(statuscode!)+"</h2><p>Problem accessing "+request!.getRequestURI()+". Reason:<hr><blockquote><pre>!ERROR="+errorcode$+" "+str(errormsg!))
                if debug and statuscode! <> "401" then
                    s!.write($0a$+stacktrace$)
                endif
                s!.write("</pre></blockquote><hr></p></body></html>")
                response!.setStatus(num(statuscode!))
            endif
            rem ToDo: add error output for xml and csv
            #logResponse(req_id$,response!)
            methodret
        fi


        rs! = answer!.get("resultset",err=*next)
        pk! = answer!.get("primarykey",err=*next)
        if rs! = null()
            s! = response!.getOutputStream()
            s!.write(str(answer!))
            response!.setHeader("Reason-Phrase",str(errormsg!))
            System.out.println("REST: error 500 "+str(errormsg!))
            response!.sendError(500,str(errormsg!))
            #logResponse(req_id$,response!)
            methodret
        fi

        if method$ = "PUT" or method$ = "DELETE" then
            response!.setStatus(num(statuscode!))
            if method$ = "DELETE" then
                #logResponse(req_id$,response!)
                methodret
            endif
        endif

        if method$ = "POST" then
            if statuscode! <> null() then
                response!.setStatus(num(statuscode!))
            endif
            if str(rs!) = "" then
                #logResponse(req_id$,response!)
                methodret
            endif
        endif

        rem Set the String value's character set based on the Accept-Charset value(if set)
        if request!.getHeader("Accept-Charset") <> null() then
            charset! = request!.getHeader("Accept-Charset")
            #setCharacterSet(rs!, charset!)
        endif

        if pos("text/html"=accept$) > 0 OR pos("*/*"=accept$) > 0  then
            if rs!.size() then
                custom_css! = rs!.get(0).getAttribute("CUSTOM_CSS")
            endif
            response!.setContentType("text/html; charset="+info(1,2))
            
            if custom_css! <> null() then
                resp_str!="<html><head><style>table, th, td {padding:5px;border: 1px solid black;} "+str(custom_css!)+"</style></head><body>"
            else
                resp_str!="<html><head><style>table, th, td {padding:5px;border: 1px solid black;}</style></head><body>"
            endif
            
            single = num(answer!.get("single",err=*next),err=*next)
            if single>0 AND rs!.size()=1 then
                rem TODO move this pivoted display into the writer
                rec! = rs!.get(0)
                it! = rec!.getFieldNames().iterator()
                resp_str! = resp_str!+"<table>"
                if request!.getPathInfo().endsWith("/_meta") then
                    attrSet! = new java.util.HashSet()
                    while it!.hasNext()
                        f$ = it!.next()
                        attrSet!.addAll(rs!.getColumnMetaData(f$).keySet())
                    wend
                    it! = attrSet!.iterator()
                    resp_str! = resp_str!+"<tr><td></td>"
                    while it!.hasNext()
                        metaName$ = it!.next()
                        resp_str! = resp_str!+"<td><b>"+metaName$+"</b></td>"
                    wend
                    resp_str! = resp_str!+"</tr>"
                    it! = rec!.getFieldNames().iterator()
                    while it!.hasNext()
                        f$ = it!.next()
                        metaMap! = rs!.getColumnMetaData(f$)
                        resp_str! = resp_str!+"<tr><td><b>"+f$+"</b></td>"
                        it2! = attrSet!.iterator()
                        while it2!.hasNext()
                            metaName$ = it2!.next()
                            if metaMap!.containsKey(metaName$) then
                                resp_str! = resp_str!+"<td>"+str(metaMap!.get(metaName$))+"</td>"
                            else
                                resp_str! = resp_str!+"<td></td>"
                            endif
                        wend
                        resp_str! = resp_str!+"</tr>"
                    wend
                else
                    while it!.hasNext()
                        f$=it!.next()
                        resp_str! = resp_str!+"<tr><td><b>"+f$+"</b></td><td>"+rec!.getFieldAsString(f$)+"</td></tr>"
                    wend
                endif
                resp_str! = resp_str!+"</table>"
            else
                if (pk! <> null() ) then
                    pk$=str(pk!)
                    links! = new java.util.HashMap()
                    link$ = request!.getContextPath()+request!.getServletPath()+request!.getPathInfo().replaceAll("(/[^/]+)/.*|$","$1")

                    while pk$>""
                        if pos("/"=pk$)>0 then
                            f$=pk$(1,pos("/"=pk$)-1)
                            pk$=pk$(pos("/"=pk$)+1)
                        else
                            f$=pk$
                            pk$=""
                        fi
                        link$=link$+"/{"+f$+"}"
                        links!.put(f$,link$)
                    wend
                else
                    links! = null()
                fi
                wr! = new java.io.StringWriter()

                ResultSetExporter.writeHTML(rs!,wr!,links!)
                wr!.flush()
                wr!.close()
                resp_str! = resp_str!+wr!.toString()
            fi
            resp_str! = resp_str!+"</body></html>"

            if (restbridge_opt_enablegzip>0 and do_gzip) then
                #writeGZipCompressedData(response!, resp_str!.getBytes())
            else
                s! = response!.getOutputStream()   
                s!.write(resp_str!)
                s!.close()
            fi

            response!.setStatus(200)
            #logResponse(req_id$,response!)
            methodret
        else
            if pos("text/xml"=accept$) >0 or pos("application/xml"=accept$) >0  then
                if pos("application/xml"=accept$) >0  then
                    response!.setContentType("application/xml")
                else
                    response!.setContentType("text/xml")
                endif
                wr! = new java.io.StringWriter()
                ResultSetExporter.writeXML(rs!,"root","entity",wr!)
                
                wr!.flush()
                wr!.close()
                    
                if (restbridge_opt_enablegzip>0 and do_gzip) then
                    #writeGZipCompressedData(response!, wr!.toString().getBytes())
                else
                    s! = response!.getOutputStream()
                    s!.write(wr!.toString())
                    s!.close()
                fi
                
                #logResponse(req_id$,response!)
                methodret
            else
                if pos("application/json"=accept$) > 0 then
                    response!.setContentType("application/json")
                    wr! = new java.io.StringWriter()
                    ResultSetExporter.writeJSON(rs!,wr!,restbridge_opt_jsonmeta)
                    wr!.flush()
                    wr!.close()
                    
                    if (restbridge_opt_enablegzip>0 and do_gzip) then
                        #writeGZipCompressedData(response!, wr!.toString().getBytes())
                    else
                        s! = response!.getOutputStream()    
                        s!.write(wr!.toString())
                        s!.close()
                    fi

                    #logResponse(req_id$,response!)
                    methodret
                else
                    if pos("text/csv"=accept$) >0 OR pos("text/plain"=accept$) >0 then
                        response!.setContentType("text/csv")
                        wr! = new java.io.StringWriter()
                        ResultSetExporter.writeTXT(rs!,wr!)

                        wr!.flush()
                        wr!.close()

                        if (restbridge_opt_enablegzip>0 and do_gzip) then
                            #writeGZipCompressedData(response!, wr!.toString().getBytes())
                        else
                            s! = response!.getOutputStream()    
                            s!.write(wr!.toString())
                            s!.close()
                        fi

                        #logResponse(req_id$,response!)
                        methodret
                    else
                        if pos("application/xls"=accept$) >0 then
                            response!.setContentType("application/xls")
                            if request!.getPathInfo().matches("/[^/]+/_output_/([^/]+)$") then
                                filename$ = request!.getPathInfo().replaceAll("/[^/]+/_output_/([^/]+)$","$1")
                            else
                                filename$ = request!.getPathInfo().replaceAll("/([^/]+).*","$1")+".xlsx"
                            endif
                           
                            response!.setHeader("content-disposition","attachment; filename="""+filename$+"""")
                            d$=System.getProperty("basis.cacheDirectory")+"/_output_/"
                            mkdir d$,err=*next

                            wr! = new java.io.StringWriter()
                            f! = java.io.File.createTempFile("output_", "xls", new java.io.File(d$))
                            ResultSetExporter.writeXLSX(rs!, f!, 1)

                            if debug then
                                System.out.println("REST: WRITING Excel to "+d$)
                                System.out.println(f!.getAbsolutePath())
                                System.out.println(str(rs!.size())+" Records written")
                            fi

                            java.nio.file.Files.copy(f!.toPath(), response!.getOutputStream())
                            f!.delete()
                            #logResponse(req_id$,response!)
                            methodret
                        else
                            if pos("debug"=accept$)>0 then
                                response!.setContentType("text/plain")
                                s! = response!.getOutputStream()
                                s!.write(str(req!))
                                s!.write($0a$)

                                s!.write(str(answer!))
                                s!.write($0a$)
                                s!.write("Debug: ")
                                s!.write($0a$)
                                s!.write("getAttributeNames:"+str(request!.getAttributeNames()))
                                s!.write($0a$)
                                s!.write("getHeaderNames:"+str(request!.getHeaderNames()))
                                s!.write($0a$)
                                s!.write("getParameterNames:"+str(request!.getParameterNames()))
                                s!.write($0a$)
                                s!.write("getMethod:"+str(request!.getMethod()))
                                s!.write($0a$)
                                s!.write("getRequestURL:"+str(request!.getRequestURL()))
                                s!.write($0a$)
                                s!.write("getRequestURI:"+str(request!.getRequestURI()))
                                s!.write($0a$)
                                s!.write("Accept:"+str(request!.getHeader("Accept")))
                                s!.write($0a$)
                                #logResponse(req_id$,response!)

                                methodret
                            else
                                if debug then
                                    System.out.println("REST: error 406 Unsupported content type requested in Accept header: "+accept$)
                                fi
                                response!.sendError(406, "Unsupported content type requested in Accept header: "+accept$)
                                #logResponse(req_id$,response!)
                                methodret
                            fi
                        fi
                    fi
                fi
            fi
        fi
        #logResponse(req_id$,response!)
        methodret

        setup_err:
            response!.setContentType("text/plain")
            s! = response!.getOutputStream()
            s!.write("stbl not set up correctly!")
            System.out.println("REST: error 500 STBLs not set up correctly! Need REST_WD and REST_ADAPTERPGM in config.bbx" )
            response!.sendError(500,"STBLs not set up correctly! Need REST_WD and REST_ADAPTERPGM in config.bbx" )
            #logResponse(req_id$,response!)
    METHODEND


    method private Boolean checkSession(BBjString ses$)

        requestSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_REQUEST_SEM",err=noSes)
        responseSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_RESPONSE_SEM")

        BBjAPI().getGlobalNamespace().setValue(ses$+"_REQUEST","PING")

        requestSemaphore!.release()
        if !responseSemaphore!.tryAcquire(1,1,java.util.concurrent.TimeUnit.SECONDS) then
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_REQUEST")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_RESPONSE")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_REQUEST_SEM")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_RESPONSE_SEM")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_SERVLET_PARAMETERS")
            methodret Boolean.FALSE
        fi

        methodret Boolean.TRUE


        noSes:
            methodret Boolean.FALSE

    methodend

    rem /**
    rem  * This method converts the VARCHAR and LONGVARCHAR field values 
    rem  * of the given ResultSet to the given charset. 
    rem  * 
    rem  * This method is used when the Accept-Charset header was specified 
    rem  * so that the RestBridge returns the Data in the requested charset.
    rem  * 
    rem  * @param resultSet! The ResultSet whose VARCHAR and LONGVARCHAR fields will be converted
    rem  * @param charset! The character Set to use for the VARCHAR fields
    rem  *
    rem  */
    method private static void setCharacterSet(ResultSet resultSet!, String charset!)
        charsetIsSupported! = Boolean.FALSE
        charsetIsSupported! = java.nio.charset.Charset.isSupported(charset!, err=*next)
        if !charsetIsSupported! then
            methodret
        endif

        if resultSet! = null() or resultSet!.isEmpty() then
            methodret 
        endif

        rsIterator! = resultSet!.iterator()
        while rsIterator!.hasNext()
            dataRow! = rsIterator!.next()
            
            fieldNames! = dataRow!.getFieldNames()
            if fieldNames!.isEmpty() then
                continue
            endif
            
            fieldNameIterator! = fieldNames!.iterator()
            while fieldNameIterator!.hasNext()
                fieldName! = fieldNameIterator!.next()

                fieldType! = dataRow!.getFieldType(fieldName!)
                if fieldType! = java.sql.Types.VARCHAR OR fieldType! = java.sql.Types.LONGVARCHAR then
                    dataRow!.setFieldValue(fieldName!, new String(dataRow!.getFieldAsString(fieldName!), charset!))
                endif
            wend
        wend
    methodend

    method public static BBjString newSession(BBjString auth$, HashMap servletParams!)

        rem create a new session
        while 1
            ses$=str(java.util.UUID.randomUUID())
            print "trying to create session "+ses$
            BBjAPI().getGlobalNamespace().getValue(ses$+"_REQUEST",err=*next); continue
            break
        wend
        System.out.println("REST: create "+ses$)
        BBjAPI().getGlobalNamespace().setValue(ses$+"_REQUEST","")
        BBjAPI().getGlobalNamespace().setValue(ses$+"_RESPONSE","")
        BBjAPI().getGlobalNamespace().setValue(ses$+"_SERVLET_PARAMETERS",servletParams!)

        requestSemaphore! = new java.util.concurrent.Semaphore(0)
        responseSemaphore! = new java.util.concurrent.Semaphore(0)
        BBjAPI().getGlobalNamespace().setValue(ses$+"_REQUEST_SEM",requestSemaphore!)
        BBjAPI().getGlobalNamespace().setValue(ses$+"_RESPONSE_SEM",responseSemaphore!)

        cp$=BBjAPI().getConfig().getCurrentCommandLineObject().getOriginalClasspathName()
        if cp$>"" cp$=" -CP"+cp$
        wd$=" -WD"+servletParams!.get("REST_WD").toString()
        pgm$=" "+servletParams!.get("REST_ADAPTERPGM").toString()


        cfg$=" -c"+BBjAPI().getConfig().getCurrentCommandLineObject().getConfigFile()
        t$=" -t"+BBjAPI().getConfig().getCurrentCommandLineObject().getTerminal()
        if servletParams!.containsKey("REST_ADAPTERTERM") then
            t$=" -t"+servletParams!.get("REST_ADAPTERTERM").toString()
        endif

        scmd$="bbj  -q "+t$+cfg$+cp$+wd$+pgm$+" - "+ses$+" "+auth$+" &"
        System.out.println("REST: create "+scmd$)
        a=scall(scmd$)

        methodret ses$

    methodend


    method public static HashMap invoke(BBjString ses$, HashMap instructions!)

        System.out.println("REST: invoke "+ses$)
        requestSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_REQUEST_SEM",err=noSes)
        responseSemaphore! = BBjAPI().getGlobalNamespace().getValue(ses$+"_RESPONSE_SEM")
        BBjAPI().getGlobalNamespace().setValue(ses$+"_REQUEST",instructions!)
        requestSemaphore!.release()
        rem here's the remote session active

        if !responseSemaphore!.tryAcquire(1,60,java.util.concurrent.TimeUnit.SECONDS) then
            rem System.out.println("Bridge: Timeout waiting on "+ses$)
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_REQUEST")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_RESPONSE")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_REQUEST_SEM")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_RESPONSE_SEM")
            BBjAPI().getGlobalNamespace().removeValue(ses$+"_SERVLET_PARAMETERS")
            System.out.println("REST: timeout on invoke "+ses$)
            throw "Timeout occurred",0
        fi
        
        response! = BBjAPI().getGlobalNamespace().getValue(ses$+"_RESPONSE",err=*next)

        System.out.println("REST: invoke done "+ses$)
        methodret response!


        noSes:
            throw  "Session invalid",11

    methodend

    method private BBjString logRequest(BBjspWebRequest request!)

        rlog$=stbl("REST_REQUESTLOG",err=skip)
        System.out.println("Logging request into "+rlog$)
        id$=""

        ch=unt
        open (ch)rlog$

        dim log$:#LOGTPL$

        id$=str(System.currentTimeMillis())+"_"+str(dec(INFO(3,0)):"000000")

        log.id$=id$
        log.METHOD$=str(request!.getMethod())
        log.START=System.currentTimeMillis()
        log.ADDR$=str(request!.getRemoteAddr())
        log.URI$=str(request!.getRequestURI())
        log.URL$=str(request!.getRequestURL())
        log.QUERY$=str(request!.getQueryString())

        h! = request!.getHeaderNames()
        it! =h!.iterator()
        while it!.hasNext()
            hn$=it!.next()
            h$=h$+hn$+"="+str(request!.getHeader(hn$))+","
        wend
        log.HEADERS$=h$

        p! = request!.getParameterNames()
        it! =p!.iterator()
        while it!.hasNext()
            pn$=it!.next()
            p$=p$+pn$+"="+str(request!.getParameter(pn$))+","
        wend
        log.PARAMS$=p$

        write record (ch)log$

        close (ch)

        skip:

        methodret id$

    methodend

    method private void logResponse(BBjString id$, BBjspWebResponse response!)

        if id$="" then
            methodret
        fi

        rlog$=stbl("REST_REQUESTLOG",err=skip)

        ch=unt
        open (ch,err=skip)rlog$

        dim log$:#LOGTPL$
        log.id$=id$
		System.out.println("------------------------")
		System.out.println(log.id$)
		System.out.println("------------------------")
        read record (ch,dom=skip,key=log.id$)log$
        log.END=System.currentTimeMillis()
        log.DURATION = log.END-log.START

        log.STATUS$=STR(response!.getStatus())

        write record (ch)log$

        close (ch)

        skip:

    methodend

    method private HashMap getRequestLog(BBjspWebRequest request!)

        answer! = new HashMap()
        rs! = new ResultSet()

        rlog$=stbl("REST_REQUESTLOG",err=skip)


        ch=unt
        open (ch,err=skip)rlog$

        tpl$=#LOGTPL$
        dim log$:tpl$

        while 1
            read record (ch,end=*break)log$
            dr! = com.basiscomponents.db.DataRow.fromTemplate(tpl$,log$)
            rs!.addItem(dr!)
        wend

        close (ch)

        answer!.put("statuscode","200")
        answer!.put("resultset",rs!)
        answer!.put("single",0)
        methodret answer!

        skip:
            answer!.put("statuscode","404")
            answer!.put("errormsg","request logging not enabled")
            answer!.put("single",0)
            methodret answer!

    methodend

    rem /**
    rem  * Returns a HashMap containing the parameter names and values defined for the RestBridge.
    rem  * <br>
    rem  * It is currently possible to define the RestBridge parameters in the servlet configuration 
    rem  * and in the servlet's config.bbx file. This method prioritizes the servlet parameters, meaning 
    rem  * if a RestBridge parameter is defined as servlet parameter and in the config.bbx, the parameter 
    rem  * from the servlet configuration will be added to the HashMap.
    rem  * <br>
    rem  * The current RestBridge parameters are: <br>
    rem  * <ul>
    rem  *     <li>REST_PGM_PREFIX</li>
    rem  *     <li>REST_PGM_SUFFIX</li>
    rem  *     <li>REST_WD</li>
    rem  *     <li>REST_ADAPTERPGM</li>
    rem  *     <li>REST_ADAPTERTERM</li>
    rem  *     <li>REST_TIMEOUT</li>
    rem  *     <li>REST_AUTHPGM</li>
    rem  *     <li>REST_REQUESTLOG</li>
    rem  *     <li>USE_GET_ALLOWED_FILTER</li>
    rem  * </ul>
    rem  * <br>
    rem  * Some of these parameters are explicitly required to be set as STBLs. This method will set them 
    rem  * as STBL if required, so that the user can define all parameters in one place.
    rem  * 
    rem  * @param context! The servlet context used to read the parameters defined for the RestBridge servlet
    rem  * @return a HashMap with the RestBridge parameters(=options) currenlty set.
    rem  */
    method private static HashMap getServletParameters(BBjspServletContext context!)

        rem the list of available parameter names
        declare BBjVector parameterNames!
        parameterNames! = new BBjVector()
        parameterNames!.add("REST_PGM_PREFIX")
        parameterNames!.add("REST_PGM_SUFFIX")
        parameterNames!.add("REST_WD")
        parameterNames!.add("REST_ADAPTERPGM")
        parameterNames!.add("REST_ADAPTERTERM")
        parameterNames!.add("REST_TIMEOUT")
        parameterNames!.add("REST_AUTHPGM")
        parameterNames!.add("REST_REQUESTLOG")
        parameterNames!.add("USE_GET_ALLOWED_FILTER")
        parameterNames!.add("REST_INPUTHANDLER")

        rem the list of parameter names that must be set as STBL 
        declare BBjVector parameterNamesToSetAsSTBL!
        parameterNamesToSetAsSTBL! = new BBjVector()
        parameterNamesToSetAsSTBL!.add("REST_WD")
        parameterNamesToSetAsSTBL!.add("REST_ADAPTERPGM")
        parameterNamesToSetAsSTBL!.add("REST_REQUESTLOG")

        declare HashMap parameterMap!
        declare BBjString parameterValue!

        rem the map to fill with the parameter names and values
        parameterMap! = new HashMap()
        for i=0 to parameterNames!.size() -1
            parameterName! = parameterNames!.get(i)
            parameterValue! = context!.getInitParameter(parameterName!)

            if parameterValue! <> null() then
                parameterMap!.put(parameterName!,parameterValue!)

                rem Setting the parameter as STBL
                if parameterNamesToSetAsSTBL!.contains(parameterName!) then
                    void$ = stbl(parameterName!,parameterValue!)
                endif
            else
                parameterMap!.put(parameterName!,stbl(parameterName!,err=*next))
            endif
        next i

        methodret parameterMap!
    methodend

    rem /**
    rem  * Writes the given content in GZIP format into the given response
    rem  * 
    rem  * @param response! The response object to write the content into
    rem  * @param content! The byte array content to write as response
    rem  */
    method private void writeGZipCompressedData(BBjspWebResponse response!, byte[] content!)
        rem Setting the correct header
        response!.setHeader("content-encoding","gzip")

        declare byte[] compressedData!
        declare GZIPOutputStream gzipOutputStream!
        declare ByteArrayOutputStream byteArrayOutputStream!

        outputStream! = response!.getOutputStream()
        byteArrayOutputStream! = new ByteArrayOutputStream()

        gzipOutputStream! = new GZIPOutputStream(byteArrayOutputStream!)
        gzipOutputStream!.write(content!)
        gzipOutputStream!.close()

        compressedData! = byteArrayOutputStream!.toByteArray()
        outputStream!.write(compressedData!)
        outputStream!.close()
    methodend

classend
